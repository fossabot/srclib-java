diff -r 27bb4c63fd70 src/share/classes/com/sun/tools/javac/comp/Attr.java
--- a/src/share/classes/com/sun/tools/javac/comp/Attr.java	Wed Feb 18 12:11:13 2015 -0800
+++ b/src/share/classes/com/sun/tools/javac/comp/Attr.java	Mon Mar 02 13:55:22 2015 -0800
@@ -1451,21 +1451,29 @@
                 case APPLY:
                     JCMethodInvocation speculativeMethodTree =
                             (JCMethodInvocation)deferredAttr.attribSpeculative(tree, env, unknownExprInfo);
-                    Type owntype = TreeInfo.symbol(speculativeMethodTree.meth).type.getReturnType();
-                    return types.unboxedTypeOrType(owntype).isPrimitive();
+                    Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
+                    if (msym == null) return false;
+                    Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
+                            env.enclClass.type :
+                            ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
+                    Type owntype = types.memberType(receiverType, msym).getReturnType();
+                    return primitiveOrBoxed(owntype);
                 case NEWCLASS:
                     JCExpression className =
                             removeClassParams.translate(((JCNewClass)tree).clazz);
                     JCExpression speculativeNewClassTree =
                             (JCExpression)deferredAttr.attribSpeculative(className, env, unknownTypeInfo);
-                    return types.unboxedTypeOrType(speculativeNewClassTree.type).isPrimitive();
+                    return primitiveOrBoxed(speculativeNewClassTree.type);
                 default:
                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo).type;
-                    speculativeType = types.unboxedTypeOrType(speculativeType);
-                    return speculativeType.isPrimitive();
+                    return primitiveOrBoxed(speculativeType);
             }
         }
         //where
+            boolean primitiveOrBoxed(Type t) {
+                return (!t.hasTag(TYPEVAR) && types.unboxedTypeOrType(t).isPrimitive());
+            }
+
             TreeTranslator removeClassParams = new TreeTranslator() {
                 @Override
                 public void visitTypeApply(JCTypeApply tree) {
diff -r 27bb4c63fd70 src/share/classes/com/sun/tools/javac/comp/DeferredAttr.java
--- a/src/share/classes/com/sun/tools/javac/comp/DeferredAttr.java	Wed Feb 18 12:11:13 2015 -0800
+++ b/src/share/classes/com/sun/tools/javac/comp/DeferredAttr.java	Mon Mar 02 13:55:22 2015 -0800
@@ -1209,7 +1209,10 @@
                 return;
             }
             scan(tree.falsepart);
-            result = reduce(ArgumentExpressionKind.PRIMITIVE);
+            result = reduce(ArgumentExpressionKind.PRIMITIVE).isPrimitive() ?
+                    ArgumentExpressionKind.PRIMITIVE :
+                    ArgumentExpressionKind.POLY;
+
         }
 
         @Override
